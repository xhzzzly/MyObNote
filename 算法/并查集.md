# 查询的优化

递归版

```c++
int find_root(const int &x) {
	if (x != s[x])
		s[x] = find_root(s[x]);
	return s[x];
}
```

非递归版

```c++
int find_root(const int &x) {
	int r = x;
	while (s[r] != r)
		r = s[r];
	int now = x;
	while (now != r) {
		const int next = s[now];
		s[now] = r;
		now = next;
	}
	return r;
}
```

# 优化合并

使用树高的概念，将高度小的树合并到高度大的树上。但这样还是不如「查询的优化」快，因为那样树高永远只有1。下面是示例代码

```c++
// 此处用到的 find_set 即是 fint_root，但不新连接，不然高度值没意义

int height[N]
void init_set() {
    for (int i =1; i <= N; ++i) {
        s[i] = i;
        height[i] = 0;
    }
}
void merge_set(int x, int y)
{
    x = find_set(x);
    y = find_set(y);
    if (height[x] == height[y]) {
        ++height[x];
        s[y] = x;
    } else {
        if (height[x] < heigth[y]) s[x] = y;
        else s[y] = x;
    }
}
```

